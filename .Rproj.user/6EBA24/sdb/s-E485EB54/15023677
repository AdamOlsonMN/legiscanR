{
    "contents" : "legiscanBill <- function(file) {\n  \n  # Need to make sure the XML and lubridate libraries are loaded when function is called\n  # may move these to be loaded when the package is loaded\n  # require(XML); require(lubridate); require(plyr); require(dplyr)\n  \n  # Create a bill object with the parsed XML content\n  bill <- xmlRoot(xmlParse(file))\n  \n  # Extract the bill elements from the bill object to be further processed\n  billobject <- bill[[\"bill\"]]\n  \n  # Create the session ID/name list\n  session <- as.data.frame(xmlToList(billobject[[\"session\"]]), \n                           stringsAsFactors = FALSE)\n  \n  # Define named list with all of the single element values\n  singleValueList <- list(bill_id = \"bill_id\", change_hash = \"change_hash\", url = \"url\", \n                          state_link = \"state_link\", completed = \"completed\", \n                          status = \"status\", status_date = \"status_date\", state = \"state\",\n                          state_id = \"state_id\", bill_number = \"bill_number\", \n                          bill_type = \"bill_type\", body = \"body\",\n                          body_id = \"body_id\", current_body = \"current_body\", \n                          current_body_id = \"current_body_id\", title = \"title\", \n                          description = \"description\", committee = \"committee\")\n  \n  # Build the list containing all the single element values\n  billData <- lapply(singleValueList, FUN = function(singles){\n    xmlToList(billobject[[singles]])\n  })\n  \n  # Replace any NULL values with NA values\n  billData <- lapply(billData, FUN = function(rmNulls) {\n    if (is.null(rmNulls)) rmNulls <- \"\"\n    else rmNulls <- rmNulls\n  })\n  \n  # Recast the date values as dates\n  billData$status_date <- ymd(billData$status_date)\n  \n  # Create bill metadata data frame object\n  billData <- cbind(session[1], as.data.frame(billData, \n                                              stringsAsFactors = FALSE))\n  \n  # Create the bill history object (contains multiple lists)\n  history <- xmlApply(billobject[[\"history\"]], \n                      FUN = function(x){\n                        list(\n                          date = ymd(xmlValue(x[[\"date\"]])),\n                          action = xmlValue(x[[\"action\"]]),\n                          chamber = xmlValue(x[[\"chamber\"]]),\n                          chamber_id = xmlValue(x[[\"chamber_id\"]]),\n                          importance = xmlValue(x[[\"importance\"]])\n                        )\n                        \n                      }\n  )\n  \n  # ID References for history table\n  historyIDs <- cbind(billData[c(1, 2, 11, 10)])\n  \n  # Convert the history object to a data frame and prevent NULL values from causing problems\n  history <- rbind.fill(lapply(history, function(f) {\n    as.data.frame(Filter(Negate(is.null), f), stringsAsFactors = FALSE)\n  }))\n  \n  # Replicate the number of rows of history IDs needed to file the history data frame\n  historyIDs <- historyIDs[rep(seq_len(nrow(historyIDs)), nrow(history)), ]\n  \n  # Add ID references to bill history dataframe\n  history <- cbind(historyIDs, history)    \n  \n  # Create the bill progress object (contains multiple lists)\n  progress <- xmlApply(billobject[[\"progress\"]],\n                       FUN = function(x){\n                         list(\n                           date = ymd(xmlValue(x[[\"date\"]])),\n                           event = xmlValue(x[[\"event\"]])\n                         )\n                       }\n  )\n  \n  # Convert the bill progress object to a data frame and prevent NULL values from causing problems\n  progress <- rbind.fill(lapply(progress, function(f) {\n    as.data.frame(Filter(Negate(is.null), f), stringsAsFactors = FALSE)\n  }))\n  \n  # ID References for progress table\n  progressIDs <- as.data.frame(billData[c(1, 2, 11, 10)], stringsAsFactors = FALSE)\n  \n  # Replicate the number of rows of progress IDs needed to file the progress data frame\n  progressIDs <- progressIDs[rep(seq_len(nrow(progressIDs)), nrow(progress)), ]\n  \n  # Add ID references to progress object\n  progress <- cbind(progressIDs, progress)\n  \n  # Create the bill sponsors object (also contains multiple lists)\n  sponsors <- xmlApply(billobject[[\"sponsors\"]],\n                       FUN = function(x){\n                         list(\n                           people_id = xmlValue(x[[\"people_id\"]]),\n                           name = xmlValue(x[[\"name\"]]),\n                           role_id = xmlValue(x[[\"role_id\"]]),\n                           ftm_id = xmlValue(x[[\"ftm_id\"]]),\n                           sponsor_type_id = xmlValue(x[[\"sponsor_type_id\"]]),\n                           sponsor_order = xmlValue(x[[\"sponsor_order\"]])\n                         )\n                       }\n  )\n  \n  # ID References for sponsors tables\n  sponsorIDs <- cbind(billData[c(1, 2, 11, 10)])\n  \n  # Convert the bill sponsors object to a data frame and prevent NULL values from causing problems\n  sponsors <- rbind.fill(lapply(sponsors, function(f) {\n    as.data.frame(Filter(Negate(is.null), f), stringsAsFactors = FALSE)\n  }))\n  \n  # Replicate the number of rows of sponsor IDs needed to file the sponsors data frame\n  sponsorIDs <- sponsorIDs[rep(seq_len(nrow(sponsorIDs)), nrow(sponsors)), ]\n  \n  # Add ID references to sponsors table\n  sponsors <- cbind(sponsorIDs, sponsors)\n  \n  if (!is.null(billobject[[\"texts\"]])) {\n    \n    # Create the bill text object (will need to pass \n    # the state_link slot to separate function to retrieve text)\n    texts <- xmlApply(billobject[[\"texts\"]],\n                      FUN = function(x){\n                        list(\n                          doc_id = xmlValue(x[[\"doc_id\"]]),\n                          date = ymd(xmlValue(x[[\"date\"]])),\n                          type = xmlValue(x[[\"type\"]]),\n                          mime = xmlValue(x[[\"mime\"]]),\n                          url = xmlValue(x[[\"url\"]]),\n                          state_link = xmlValue(x[[\"state_link\"]])\n                        )\n                      }\n    )\n    \n    # Generate a list of all of the state link elements\n    linkLists <- lapply(texts, FUN = function(x){\n      list(x[[\"state_link\"]])\n    })\n    \n    # Retrieve, parse, and clean the text of the bills\n    cleanText <- lapply(linkLists, FUN = function(links) {\n      tryCatch(paste(xpathApply(htmlParse(links), \n                                \"//p\", xmlValue), collapse = \"\\n\"),\n               error = function(e) {\n                 list(c(\"drop me\"), \n                      c(\"Error loading the bill text\"))\n               })\n    })\n    \n    # Create data table with the text data\n    fullText <- ldply(cleanText, rbind)\n    \n    # Convert text back to character vector\n    fullText[, 2] <- toString(fullText[, 2])\n    \n    # Assign a name to the cleaned full text data table\n    names(fullText) <- c(\"drop\", \"full_bill_text\")\n    \n    # Remove the ID column generated by dplyr\n    fullText <- fullText[, 2]\n    \n    # Convert the bill texts object to a data frame and prevent NULL values from causing problems\n    texts <- rbind.fill(lapply(texts, function(f) {\n      as.data.frame(Filter(Negate(is.null), f), stringsAsFactors = FALSE)\n    }))\n    \n  } else {\n    \n    # Create NULL Texts object\n    texts <- as.data.frame(cbind(doc_id = NA, date = NA,\n                                 type = NA, mime = NA, url = NA, \n                                 state_link = NA))\n  }\n  \n  # ID References for text tables\n  textIDs <- cbind(billData[c(1, 2, 10, 11, 14, 15, 16)])\n  \n  # Copy the appropriate number of rows for the text IDs object\n  textIDs <- textIDs[rep(seq_len(nrow(textIDs)), nrow(texts)), ]\n  \n  # Add ID references to text tables\n  texts <- cbind(textIDs, texts, full_bill_text = fullText, \n                 stringsAsFactors = FALSE)\n  \n  # ID References for votes tables\n  voteIDs <- cbind(billData[c(1, 2, 10, 11)])\n  \n  # Check to see if the votes object is null\n  if (!is.null(billobject[[\"votes\"]])) {\n    \n    # Create the bill voting records object \n    # Note: pass the state_link slot to the votingRecords function to retrieve and parse the\n    # pdf formatted versions of the voting records from the state's website\n    votes <- xmlApply(billobject[[\"votes\"]],\n                      FUN = function(x){\n                        list(\n                          roll_call_id = xmlValue(x[[\"roll_call_id\"]]),\n                          date = ymd(xmlValue(x[[\"date\"]])),\n                          passed = xmlValue(x[[\"passed\"]]),\n                          desc = xmlValue(x[[\"desc\"]]),\n                          url = xmlValue(x[[\"url\"]]),\n                          state_link = xmlValue(x[[\"state_link\"]])\n                        )\n                      }\n                    )\n    \n    # Generate a list of all of the state link elements\n    voteLists <- lapply(votes, FUN = function(x){\n      list(x[[\"state_link\"]])\n    })\n    \n    # Store parsed/cleaned voting records in dataframe\n    #individualVotes <- ldply(voteLists, votingRecords)\n        \n    # Create new ID reference for individual voting records\n    # ivoteID <- cbind(billData[c(1, 2, 10, 11)])\n    \n    # ivoteID <- ivoteID[rep(seq_len(nrow(ivoteID)), nrow(individualVotes)), ]\n    \n    # individualVotes <- cbind(ivoteID, individualVotes)\n    \n    # Convert the bill votes object to a data frame and prevent NULL values from causing problems\n    votes <- rbind.fill(lapply(votes, function(f) {\n      as.data.frame(Filter(Negate(is.null), f), stringsAsFactors = FALSE)\n    }))\n        \n  } else {\n    \n    # Create a Null data frame for the broken case\n    votes <- as.data.frame(cbind(roll_call_id = \"NULL\", date = \"NULL\", passed = \"NULL\",\n                                 desc = \"NULL\", url = \"NULL\", state_link = \"NULL\"), \n                           stringsAsFactors = FALSE)\n    \n  }\n    \n  # Copy the appropriate number of rows for the vote IDs object\n  voteIDs <- voteIDs[rep(seq_len(nrow(voteIDs)), nrow(votes)), ]\n\n  # Add the ID References to the votes table\n  votes <- cbind(voteIDs, votes)\n  \n  # Store all of the data frames in a list object that will be returned at \n  # the end of the function call\n  legiBill <- list(billMetaData = billData, billHistory = history, \n                   billProgress = progress, billSponsors = sponsors, \n                   billText = texts, billVoteOutcomes = votes)  \n  \n  # Return the list of dataframes with all of the bill data\n  return(legiBill)\n  \n  # End function call    \n}\n",
    "created" : 1418565056962.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4217883456",
    "id" : "15023677",
    "lastKnownWriteTime" : 1418606751,
    "path" : "~/legiscanR/R/legiscanBill.R",
    "project_path" : "R/legiscanBill.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}