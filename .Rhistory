prep <- preProcess(final, method = "pca", thresh = .80)
trainPC <- predict(prep, training$diagnosis)
trainPC <- predict(prep, training$diagnosis, method = "glm")
prep <- preProcess(final, method = "pca", thresh = .90)
prep
library("ggplot2")
library("foreign")
data <- as.data.frame(read.dta("http://www.paces-consulting.org/mde/data-wrkshp4-843.dta"))
qplot(female, data = data)
qplot(race, facets = female ~ frl, fill = sped, data = data)
library("truncnorm")
nwScience <- 450
nwoScience <- 250
muwScience <- 459
muwoScience <- 378
sigwScience <- "Somewhat"
sigwoScience <- "Somewhat"
# Recode variance input for schools w/Science
sigwScience <- ifelse(sigwScience == "Not Much", 25, #
ifelse(sigwScience == "Somewhat", 50, 75))
# Recode variance input for schools w/o Science
sigwoScience <- ifelse(sigwScience == "Not Much", 17.5, #
ifelse(sigwScience == "Somewhat", 28.2975, 57))
# Generate a vector of potential total points for schools w/science
wScience <- trunc(rtruncnorm(5000, a = 200, b = 700, mean = muwScience, #
sd = sigwScience) + runif(5000, min = -65, max = 47))
# Generate a vector of potential total points for schools w/o science
woScience <- trunc(rtruncnorm(5000, a = 150, b = 600, mean = muwoScience, #
sd = sigwoScience) + runif(5000, min = -55, max = 39))
# Sample the number of schools w/Science requested by user
wScience <- sample(wScience, size = nwScience)
woScience <- sample(woScience, size = nwoScience)
wScience <- wScience[order(wScience)]; woScience <- woScience[order(woScience)]
x <- quantile(wScience, probs = seq(0, 1, .01), na.rm = FALSE, names = TRUE)
xtile <- function(var) {
x <- unique(quantile(wScience, probs = seq(0, 1, .01), na.rm = FALSE, names = TRUE))
cutwsci <- unique(quantile(wScience, probs = seq(0, 1, .01), na.rm = FALSE, names = TRUE))
cutwosci <- unique(quantile(woScience, probs = seq(0, 1, .01), na.rm = FALSE, names = TRUE))
cutwsci <- quantile(unique(wScience), probs = seq(0, 1, .01), na.rm = FALSE, names = TRUE)
cutwosci <- quantile(unique(woScience), probs = seq(0, 1, .01), na.rm = FALSE, names = TRUE))
cutwosci <- quantile(unique(woScience), probs = seq(0, 1, .01), na.rm = FALSE, names = TRUE)
cutwsci <- quantile(unique(wScience), probs = seq(0.01, 1, .01), na.rm = FALSE, names = TRUE)
cutwosci <- quantile(unique(woScience), probs = seq(0.01, 1, .01), na.rm = FALSE, names = TRUE)
cutwsci <- c(1, cutwsci)
cutwsci <- c(1, quantile(unique(wScience), probs = seq(0.01, 1, .01), #
na.rm = FALSE, names = TRUE))
cutwosci <- c(1, quantile(unique(woScience), probs = seq(0.01, 1, .01), #
na.rm = FALSE, names = TRUE))
cutwsci <- c(1, quantile(unique(wScience), probs = seq(0.01, 0.99, .01), #
na.rm = FALSE, names = TRUE))
cutwosci <- c(1, quantile(unique(woScience), probs = seq(0.01, 0.99, .01), #
na.rm = FALSE, names = TRUE))
wscipctile <- cut(wScience, cutwsci, include.lowest = TRUE, right = TRUE, labels = FALSE)
woscipctile <- cut(woScience, cutwosci, include.lowest = TRUE, right = TRUE, labels = FALSE)
table(sci$wScigrades)
View(sci)
wscipctile <- cut(wScience, cutwsci, include.lowest = TRUE, right = FALSE, labels = FALSE)
woscipctile <- cut(woScience, cutwosci, include.lowest = TRUE, right = FALSE, labels = FALSE)
wScigrades <-   ifelse(wScience >= 518, 1,                            #
ifelse(wScience >= 455 & wScience <= 517, 2,          #
ifelse(wScience >= 400 & wScience <= 454, 3,          #
ifelse(wScience >= 325 & wScience <= 399, 4, 5))))
woScigrades <- NA
# Define data frames
sci <- as.data.frame(cbind(wScience, wscipctile, wScigrades, 0))
wosci <- as.data.frame(cbind(woScience, woscipctile, woScigrades, 0))
wsciA <- range(sci$wscipctile[wScigrades == 1])
wsciB <- range(sci$wscipctile[wScigrades == 2])
wsciC <- range(sci$wscipctile[wScigrades == 3])
wsciD <- range(sci$wscipctile[wScigrades == 4])
wsciF <- range(sci$wscipctile[wScigrades == 5])
# Load the foreign data package and the ggplot2 package
library("foreign"); library("ggplot2")
# Store the URL where the data can be accessed
# Load either your data or the example data (Substitute your name to get your data)
example <- as.data.frame(read.dta(paste0(url, "SharonRatliff-task3.dta")))
# Display the variable names to show the data were downloaded from the server
names(example)
# Just to make sure, also print a bunch of summary statistics
summary(example)
library(psych)
?sim.rasch
test <- as.data.frame(sim.rasch(nvar = 20, n = 28, low = -4, high = 4, a = 1, mu = -0.125, sd = 1))
test <- sim.rasch(nvar = 20, n = 28, low = -4, high = 4, a = 1, mu = -0.125, sd = 1)
View(test)
View(test@items)
View(test$items)
?read.txt
?read
?read.text
?read.csv
textExample <- read.table("~/Desktop/Dropbox/JSU/Fall2014/20141118/textexample.txt", #
header = TRUE, sep = ",", stringsAsFactors = FALSE)
View(textExample)
?rowsum
?sum
x <- cbind(x1 = 3, x2 = c(4:1, 2:5))
View(x)
rowSums(x)
colSums(x)
testData <- as.data.frame(test$items)
testData2 <- cbind(seq(1, 28, 1), testData)
View(testData2)
testData2 <- cbind(id = seq(1, 28, 1), testData)
names(testData2)
testData <- cbind(id = seq(1, 28, 1), as.data.frame(test$items))
ggplot(testData, aes(x = V13, y = total)) + geom_box()
testData$total <- rowSums(testData[, -1])
ggplot(testData, aes(x = V13, y = total)) + geom_boxplot()
View(testData)
?geom_boxplot
ggplot(testData, aes(x = factor(V13), y = total)) + geom_boxplot()
?biserial
biserial(testData$V13, testData$total)
biserial(factor(testData$V13), testData$total)
biserial(testData$total, testData$V13)
f <- function(dataFrame, index) { }
return(biserial(dataSample$total, dataSample$V13))
library(boot)
bootstrapped.biserial <- boot(testData, f, R = 1000)
summary(bootstrapped.biserial)
cor(testData$studentid, testData$total)
cor(testData$id, testData$total)
f <- function(dataFrame, index) {
dataSample <- dataFrame[index, ]
return(cor(dataSample$total, dataSample$id))
return(biserial(dataSample$total, dataSample$V13, ))
rm(f)
library(polycor)
?polycor
?polychor
install.packages(ltm, dep = TRUE)
install.packages("msm", dep = TRUE)
install.packages("msm", dep = TRUE, type = "source")
install.packages("ltm", dep = TRUE)
library(ltm)
?ltm
incorrect <- biserial.cor(dataSample$total, dataSample$V13)
correct <- biserial.cor(dataSample$total, dataSample$V13, level = 2)
return(cbind(incorrect, correct))
f <- function(dF, i) {
dataSample <- dF[i, ]
return(biserial.cor(dataSample$total, dataSample$V13, level = 2))
}
bootcorr <- boot(testData, f, R = 500)
bootcorr <- boot(testData, f, R = 5000)
bootcorr
?boot
summary(bootcorr)
hrow = c(" ", "Nominal", "Ordinal", "Intervallic/Ratio")
nrow = c("Nominal", "Tetrachoric", "Rank Biserial", "Point Biserial")
orow = c("Ordinal", "Rank Biserial", "Polychoric", "Polyserial")
irow = c("Intervallic/Ratio", "Point Biserial", "Polyserial", "Pearson's r")
corrs <- rbind(hrow, nrow, orow, irow)
corrs
install.packages("pander", dep = TRUE)
library(pander)
pander(corrs)
?pander
?pandoc
pandoc.table.return(corrs)
pandoc.table.return(corrs, style = "rmarkdown")
pandoc(corrs)
pandoc(corrs, style = "simple")
pandoc(corrs, style = "grid")
corrs <- rbind(c("Nominal", "Tetrachoric", "Rank Biserial", "Point Biserial"),
names(corrs) <- c(" ", "Nominal", "Ordinal", "Intervallic/Ratio")
pandoc(corrs, style = "rmarkdown")
corrs <- rbind(c(" ", "Nominal", "Ordinal", "Intervallic/Ratio"),
c("Nominal", "Tetrachoric", "Rank Biserial", "Point Biserial"),
c("Ordinal", "Rank Biserial", "Polychoric", "Polyserial"),
c("Intervallic/Ratio", "Point Biserial", "Polyserial", "Pearson's r"))
pander(corrs, style = "rmarkdown")
pander(corrs, style = "simple")
?rnorm
install.packages("VGAM", dep = TRUE)
library(vgam)
library(VGAM)
?rsnorm
x <- rskewnorm(850, 1.5, 1, 0)
plot(x)
library(ggplot2)
x <- rskewnorm(850, 1.5, 2, 0)
x <- rskewnorm(850, 1.5, 4, 0)
x <- rskewnorm(850, 1.5, 4, 1)
x <- rskewnorm(850, 1.5, 4, -3)
x <- rskewnorm(850, 1.5, 2, -3)
x <- rskewnorm(850, 1.5, 1, -3)
x <- rskewnorm(850, 3.5, 1, -3)
x <- round(rskewnorm(850, 3.5, 1, -3), 0)
x <- round(rskewnorm(850, 3.5, .5, -4), 0)
x <- round(rskewnorm(850, 3.5, .75, -4), 0)
x <- round(rskewnorm(850, 3.85, .75, -4), 0)
set.seed(7779311)
x <- round(rskewnorm(850, 3.99, .75, -4), 0)
x <- rskewnorm(890, 0, .25, 0)
x <- rskewnorm(890, 0, .005, 0)
x <- rskewnorm(890, 0, 5, 0)
x <- rskewnorm(890, 0, 1, .5)
qplot(x)
growrla <- round(rskewnorm(890, 61.6764, 4.300454, -.3158577), 0)
growmth <- round(rskewnorm(890, 68.36251, 3.411649, -.0636846), 0)
eval <- round(rskewnorm(890, 3.99, .75, -4), 0)
growrla <- rskewnorm(890, 61.6764, 4.300454, -.3158577)
growmth <- rskewnorm(890, 68.36251, 3.411649, -.0636846)
qplot(growrla)
qplot(growmth)
corr(eval, growrla, growmth)
cor(eval, growrla, growmth)
?cor
cor(eval, growrla)
cor(eval, growmth)
qplot(eval, growrla)
library(foreign)
url <- "http://www.paces-consulting.org/stata/JSU/Fall2014/"
jdoe <- <- as.data.frame(read.dta(paste0(url,
"JohnDoe-finals.dta")))
jdoe <- <- as.data.frame(read.dta(paste0(url, "JohnDoe-finals.dta")))
jdoe <- as.data.frame(read.dta(paste0(url, "JohnDoe-finals.dta")))
names(jdoe)
q()
?rbind.fill
?setMethod
?setClass
?state.abbr
?st.abbr
x <- state.abbr
?data
data()
LegiScan <- setClass("LegiScan",
slots = list(api = "character"))
LegiStates <- setClass("LegiStates",
contains = LegiScan,
slots = list(state = "character"),
validity = function(object) {
if (length(object@state) != 2) {
return("Error: The state slot must be the two letter state abbrviation")
} else if (!(object@state %in% state.abb)) {
return("Error: Invalid state abbreviation")
} else {
return(TRUE)
}
})
LegiStates <- setClass("LegiStates",
contains = LegiScan,
slots = list(state = "character",
api = LegiScan@api),
validity = function(object) {
if (length(object@state) != 2) {
return("Error: The state slot must be the two letter state abbrviation")
} else if (!(object@state %in% state.abb)) {
return("Error: Invalid state abbreviation")
} else {
return(TRUE)
}
})
LegiStates <- setClass("LegiStates",
contains = LegiScan,
slots = list(state = "character",
api = LegiScan),
validity = function(object) {
if (length(object@state) != 2) {
return("Error: The state slot must be the two letter state abbrviation")
} else if (!(object@state %in% state.abb)) {
return("Error: Invalid state abbreviation")
} else {
return(TRUE)
}
})
?setClass
LegiStates <- setClass("LegiStates",
contains = LegiScan@api,
slots = list(state = "character"),
validity = function(object) {
if (length(object@state) != 2) {
return("Error: The state slot must be the two letter state abbrviation")
} else if (!(object@state %in% state.abb)) {
return("Error: Invalid state abbreviation")
} else {
return(TRUE)
}
})
LegiScan <- setClass("LegiScan",
slots = list(api = "character"))
LegiScan <- setClass("LegiScan",
slots = list(api = "character"),
validity = function(object) {
if (is.null(api) == TRUE) {
return("Error: LegiScan API Key must be non-null")
} else if (is.na(api) == TRUE) {
return("Error: LegiScan API Key must be non-missing")
} else {
return(TRUE)
}
})
LegiStates <- setClass("LegiStates",
contains = LegiScan@api,
slots = list(state = "character"),
validity = function(object) {
if (length(object@state) != 2) {
return("Error: The state slot must be the two letter state abbrviation")
} else if (!(object@state %in% state.abb)) {
return("Error: Invalid state abbreviation")
} else {
return(TRUE)
}
})
LegiStates <- setClass("LegiStates",
contains = "LegiScan",
slots = list(state = "character"),
validity = function(object) {
if (length(object@state) != 2) {
return("Error: The state slot must be the two letter state abbrviation")
} else if (!(object@state %in% state.abb)) {
return("Error: Invalid state abbreviation")
} else {
return(TRUE)
}
})
str(LegiStates)
slots(LegiStates)
?setMethod
LegiScan <- setClass("LegiScan",
slots = list(api = "character",
state = "character",
rootURL = "character",
)
validity = function(object) {
if (is.null(api) == TRUE) {
return("Error: LegiScan API Key must be non-null")
}
if (is.na(api) == TRUE) {
return("Error: LegiScan API Key must be non-missing")
}
if (length(state) != 2) {
return("Error: The state slot must be the two letter state abbrviation")
}
if (!(state %in% state.abb)) {
return("Error: Invalid state abbreviation")
}
else {
return(TRUE)
}
})
LegiScan <- setClass("LegiScan",
slots = list(api = "character",
state = "character",
rootURL = "character")
validity = function(object) {
if (is.null(api) == TRUE) {
return("Error: LegiScan API Key must be non-null")
}
if (is.na(api) == TRUE) {
return("Error: LegiScan API Key must be non-missing")
}
if (length(state) != 2) {
return("Error: The state slot must be the two letter state abbrviation")
}
if (!(state %in% state.abb)) {
return("Error: Invalid state abbreviation")
}
else {
return(TRUE)
}
})
rm(LegiScan)
rm(LegiStates)
LegiScan <- setClass("LegiScan",
slots = list(api = "character",
state = "character",
rootURL = "character")
validity = function(object) {
if (is.null(api) == TRUE) {
return("Error: LegiScan API Key must be non-null")
}
if (is.na(api) == TRUE) {
return("Error: LegiScan API Key must be non-missing")
}
if (length(state) != 2) {
return("Error: The state slot must be the two letter state abbrviation")
}
if (!(state %in% state.abb)) {
return("Error: Invalid state abbreviation")
}
else {
return(TRUE)
}
})
LegiScan <- setClass("LegiScan",
slots = list(api = "character",
state = "character",
rootURL = "character")
validity = function(object) {
if (is.null(api) == TRUE) {
return("Error: LegiScan API Key must be non-null")
}
if (is.na(api) == TRUE) {
return("Error: LegiScan API Key must be non-missing")
}
if (!is.na(state) && length(state) != 2) {
return("Error: The state slot must be the two letter state abbrviation")
}
if (!is.na(state) && !(state %in% state.abb)) {
return("Error: Invalid state abbreviation")
}
else {
return(TRUE)
}
})
LegiScan <- setClass("LegiScan",
slots = list(api = "character",
state = "character",
rootURL = "character"),
validity = function(object) {
if (is.null(api) == TRUE) {
return("Error: LegiScan API Key must be non-null")
}
if (is.na(api) == TRUE) {
return("Error: LegiScan API Key must be non-missing")
}
if (!is.na(state) && length(state) != 2) {
return("Error: The state slot must be the two letter state abbrviation")
}
if (!is.na(state) && !(state %in% state.abb)) {
return("Error: Invalid state abbreviation")
}
else {
return(TRUE)
}
})
LegiScan <- setClass("LegiScan",
slots = list(api = "character"),
validity = function(object) {
if (is.null(api) == TRUE) {
return("Error: LegiScan API Key must be non-null")
} else if (is.na(api) == TRUE) {
return("Error: LegiScan API Key must be non-missing")
} else {
return(TRUE)
}
})
LegiStates <- setClass("LegiStates",
contains = "LegiScan",
slots = list(state = "character"),
validity = function(object) {
if (length(object@state) != 2) {
return("Error: The state slot must be the two letter state abbrviation")
} else if (!(object@state %in% state.abb)) {
return("Error: Invalid state abbreviation")
} else {
return(TRUE)
}
})
LegiSession <- setClass("LegiSession",
contains = "LegiStates",
slots = list(session_id = "list"))
LegiMaster <- setClass("LegiMaster",
contains = "LegiScan",
slots = list(state = "character",
id = "character"),
validity = function(object) {
if (length(object@state) != 2) {
return("Error: The state slot must be the two letter state abbrviation")
} else if (!(object@state %in% state.abb)) {
return("Error: Invalid state abbreviation")
} else {
return(TRUE)
}
})
LegiBill <- setClass("LegiBill",
slots = list(id = "character",
state = "character",
bill = "character"))
source('~/.active-rstudio-document')
?new.env
?get
source('~/Desktop/Programs/R/legiscanR/R/billdata.R')
source('~/Desktop/Programs/R/legiscanR/R/billids.R')
source('~/Desktop/Programs/R/legiscanR/R/legiBillProg.R')
rm(LegiBill, LegiMaster, LegiScan, LegiSession, LegiStates)
##' @title Build Directory Tree Object for Legiscan Data Downloads
source('~/Desktop/Programs/R/legiscanR/R/fileStructure.R')
source('~/Desktop/Programs/R/legiscanR/R/fileLists.R')
d <- fileStructure("~/Desktop/Programs/R/legiscanR/data/msHistoricalJSON/")
files <- fileLists(d)
y <- legiBillProg(files[[1]][[1]])
library(jsonlite)
library(plyr)
y <- legiBillProg(files[[1]][[1]])
?quote
source('~/Desktop/Programs/R/legiscanR/R/legiBillProg.R')
y <- legiBillProg(files[[1]][[1]])
source('~/Desktop/Programs/R/legiscanR/R/legiBillProg.R')
y <- legiBillProg(files[[1]][[1]])
y <- legiBillProg(files[[1]][[1]][[1]])
library(magrittr)
y <- legiBillProg(files[[1]][[1]][[1]])
q()
install.packages("broom")
devtools::install_github("dgrtwo/broom")
setwd("~/Desktop/Programs/R/legiscanR")
library(devtools)
library(roxygen)
library(roxygen2)
?devtools
create("~/Desktop/Programs/R/legiscanR")
package.skeleton(name = "legiscanR", path = "~/Desktop/Programs/R/legiscanR", force = FALSE, code_files = "~/Desktop/Programs/R/legiscanR")
list.files()
?description
??description
packageDescription("ggplot2")
?read.dcf
